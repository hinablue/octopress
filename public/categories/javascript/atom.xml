<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | HINA::工程幼稚園]]></title>
  <link href="http://blog.hinablue.me/categories/javascript/atom.xml" rel="self"/>
  <link href="http://blog.hinablue.me/"/>
  <updated>2011-11-29T23:02:43+08:00</updated>
  <id>http://blog.hinablue.me/</id>
  <author>
    <name><![CDATA[hinablue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[JS tech.] CKeditor Dialog 再起 part 5]]></title>
    <link href="http://blog.hinablue.me/entry/JS-tech-CKeditor-dialog-again-part-5/"/>
    <updated>2010-05-27T18:56:00+08:00</updated>
    <id>http://blog.hinablue.me/entry/JS-tech-CKeditor-dialog-again-part-5</id>
    <content type="html"><![CDATA[<p>在這裡開始之前，我必須告訴你們一件事情，CKeditor 內含的 Event，也就是總共可以被 fire 的監聽事件，分門別類總共有 56 種之多！其中因為 IE 的關係，selectionChange 的監聽事件分出了 IE 專用的 selectionchange（是的，僅大小寫不同），再扣除測試的兩種監聽 someEvent 與 testEvent，還有原本就在 DOM 常見的監聽式以外，CKeditor 所使用的 Event 還是高達 46 種。</p>

<p>不過，這跟 Dialog 有什麼關係？好，要啟動 Dialog 之前，由於 dialog 在 CKeditor 是一個 plugin，所以必須要先滿足一個條件：
<span style="font-weight: bold; color: rgb(212, 26, 1);">確定 plugin 已經讀取完成，那麼，我們就必須監聽 pluginsLoaded，用以得知 plugin 已經載入完畢。</span></p>

<p>CKeditor 很慷慨的分享出 JavaScript API Document，但是我很殘酷的告訴你，event 到底在幹麼他支字未提。好的，暫且將 Event 放一邊，你只要知道有這件事情就好了。往後倘若遇到 fire 事件時，再回來查吧（文末會附上列表）。</p>

<p>我們在這裡所需要準備的環境，其實很簡單，由於 CKeditor 後來提供了 jQuery Adapter 的方式來初始化編輯器，所以我們就從 jQuery 開始。</p>

<pre><code>&lt;script type="text/javascript"&gt;
//&lt;![CDDA[
</code></pre>

<!-- more -->


<pre><code>$(document).ready(function() {
    var config = {};
    $("#editor").ckeditor(function() { /*...callback here...*/ }, config);
});
//]]&gt;
&lt;/script&gt;
</code></pre>

<p>然後，我們從 callback 的地方開始我們的 dialog 設定，在這裡面我們要做很多事情：</p>

<ol><li>設定 Dialog</li><li>建立 Dialog</li><li>註冊 Dialog 元件</li><li>指定 Toolbar 按鈕</li><li>指定 Toolbar 按鈕命令</li></ol>


<p>不囉唆，請看碼說故事。</p>

<pre><code>&lt;script type="text/javascript"&gt;
//&lt;![CDDA[
$(document).ready(function() {
    var config = {};
    $("#editor").ckeditor(function() {
        var editor = this;
        // 監聽 pluginsLoaded，完成才執行。
        editor.on('pluginsLoaded', function( ev ) {
            // 檢查要建立的 dialog 是否存在，不存在則建立。
            if (!CKEDITOR.dialog.exists('myDialog')) {
                // 註冊這個 Dialog，注意，官方範例中，這裡是使用載入外部 JavaScript 來完成的。
                // 這裡的 Dialog 我直接取用上一篇的介紹，寫入檔案上傳的對話框。
                CKEDITOR.dialog.add( 'myDialog', function( editor )
                {
                    return {
            title : 'My Dialog',
            minWidth : 400,
            minHeight : 200,
            contents : [
            {
                id : 'Upload',
                hidden : true,
                filebrowser : 'uploadButton',
                label : editor.lang.image.upload,
                // 在 Dialog 中註冊元件
                elements :
                [
                    {
                    type : 'file',
                    id : 'upload',
                    label : editor.lang.image.btnUpload,
                    style: 'height:40px',
                    size : 38
                    },
                    {
                    type : 'fileButton',
                    id : 'uploadButton',
                    filebrowser : 'info:txtUrl',
                    label : editor.lang.image.btnUpload,
                    'for' : [ 'Upload', 'upload' ]
                    }
                ]
            }
            ]
            };
                });
                // 與官方不同的是，我們把工具列命令放在這裡，當然是建立 dialog 之後在給命令。
                editor.addCommand('myDialogCmd', new CKEDITOR.dialogCommand('myDialog'));
                // 同樣的，註冊一個按鈕，也放在這裡面。
                editor.ui.addButton( 'MyButton',
        {
            label : 'My Dialog',
            command : 'myDialogCmd'
        });
            }
        });
    }, config);
});
//]]&gt;
&lt;/script&gt;


    var config = {
    toolbar: [
        // 前略
        ['MyButton']
    ]
    };
</code></pre>

<p>在加入對話框的時候，發生了什麼事情？首先是對話框的名稱，請留意這個名稱在 dialog 中必須是獨一無二的。再來，我們來看看設定的部份：</p>

<ul><li>button
設定對話框按鈕，但是他不是實際可以使用的 API，請忽略他，因為他不能用（目前為只是這樣）。</li><li>content
設定對話框內容，對話框的內容由 contentDefinition 產生物件並以陣列的方式傳入。</li><li>title
設定對話框標題，必填！</li><li>minHeight
對話框最小高度。</li><li>minWidth
對話框最小寬度。</li><li>onCancel
對話框按下取消的時候，觸發這個函式。</li><li>onLoad
對話框載入的時候，觸發這個函式。</li><li>onOk
對話框按下確定的時候，觸發這個函式。</li><li>resizable
變更對話框的尺寸，預設是無法變更，不過我套用了其他三種設定也無法使用，不知道是什麼緣故。可用的數值有：
CKEDITOR.DIALOG_RESIZE_NONE
CKEDITOR.DIALOG_RESIZE_WIDTH
CKEDITOR.DIALOG_RESIZE_HEIGHT
CKEDITOR.DIALOG_RESIZE_BOTH</li></ul>


<p>接下來，我們來看 contentDefinition 做了什麼事情。他是用來定義對話框中顯示的元件，以物件方式傳入：</p>

<ul><li>accessKey
CTRL 熱鍵組合，可以快速切換到該頁內容。</li><li>elements
對話框中的 UI 元件（有限制），使用 uiElementDefinition 產生物件並以陣列的方式傳入。</li><li>title
該頁面的訊息。</li><li>label
該頁面的頁籤（tab）。</li><li>id
該頁面的 id 屬性。</li></ul>


<p>最後，我們來看 uiElementDefinition 做了什麼事情。他是用來定義對話框內容元件 UI，以物件方式傳入：</p>

<ul><li>className
該物件所套用的 CSS 類別樣式。</li><li>id
該物件所使用的 id 屬性。</li><li>type
該物件的類別，這裡的類別決定你要放置的元件設定。</li><li>onHide
該物件隱藏的時候，觸發這個函式。</li><li>onLoad
該物件載入的時候，觸發這個函式。</li><li>onShow
該物件顯示的時候，觸發這個函式。</li><li>style
該物件可以設定的行內樣式。</li></ul>


<p>這樣就結束了嗎？還沒還沒，我們再來針對 type 這個設定來看，uiElementDefinition 其實繼承（或說沿用）了 ui.dialog.uiElement 的類別。所以，他能做到的事情遠比你想像中的要複雜的多。我們先來看看到底可以在對話框中，能加入什麼東西。</p>

<ul><li>type: 'file'
提供一個檔案上傳的端口，通常搭配 fileButton 使用。</li><li>type: 'fileButton'
將 file 所提供的檔案做上傳等動作，也可以搭配 CKFinder 做檔案總管之類的動作。</li><li>type: 'hbox'
加入一個水平的方塊元件（通常是 DIV boxing）必須指定 children，可與 vbox 搭配使用做出擬似表格的顯示。</li><li>type: 'vbox'
加入一個垂直的方塊元件（通常是 DIV boxing）必須指定 children，可與 hbox 搭配使用做出擬似表格的顯示。</li><li>type: 'html'
直接寫入 HTML 標記語言，必須傳入指定內容（使用 html）。</li><li>type: 'text'
加入一個 input 欄位，屬性為 text，注意，並沒有 password 可用。</li><li>type: 'textarea'
加入一個 textarea 欄位。</li><li>type: 'checkbox'
加入一個 checkbox 項目。</li><li>type: 'radio'
加入 radio 項目，必須傳入指定項目陣列（使用 item）。</li><li>type: 'select'
加入 select 項目，必須傳入指定項目陣列（使用 item）。</li></ul>


<p>我們把上面的範例再拿來修改一下：</p>

<pre><code>elements :
[
    {
    type : 'file',
    id : 'upload',
    label : editor.lang.image.btnUpload,
    style: 'height:40px',
    size : 38
    },
    {
    type : 'fileButton',
    id : 'uploadButton',
    filebrowser : 'info:txtUrl',
    label : editor.lang.image.btnUpload,
    'for' : [ 'Upload', 'upload' ]
    },
    {
    type : 'html',
    html: '&lt;div style="background-color:#f33;"&gt;這裡是自訂的 HTML 內容&lt;/div&gt;'
    },
    {
    type : 'vbox',
    height : ['30%','70%'],
    children : [
        {
        type : 'hbox',
        widths : ['60%','40%'],
        children : [
            {
            type : 'radio',
            items : [
                ['選項 1','1'],
                ['選項 2','2'],
                ['選項 3','3']
            ]
            },
            {
            type : 'textarea',
            cols : 5,
            rows : 5,
            label : '請亂填'
            }
        ]
        },
        {
        type : 'select',
        style : 'width:100%',
        items : [
            ['選項 1','1'],
            ['選項 2','2'],
            ['選項 3','3']
        ]
        },           
        {
        type : 'checkbox',
        label : '請勾選'
        }
    ]
    },
]
</code></pre>

<p><img src="http://static.hinablue.me/blog/4221529725.png" width="450" height="468" /></p>

<p>那麼？你有覺得 Dialog 有好用一點點了嗎？至於剛剛說的 Event 列表，真的有人想看嗎？</p>

<div>[#M_ 按這裡看 Event 清單.. | 關閉清單.. |themeSpace

saveSnapshot

ariaWidget

dialogDefinition

cancel

show

dialogShow

hide

dialogHide

ok

menuShow

key

contentDom

mode

dataReady

contentDomUnload

showScaytState

scaytDialog

afterCommandExec

contextmenu

beforepaste

pasteDialog

afterUndo

afterRedo

state

beforeCleanWord

paste

instanceReady

beforeModeUnload

selectionChange

selectionchange

pluginsLoaded

instanceCreated

destroy

instanceDestroyed

beforeCommandExec

beforeGetData

getData

getSnapshot

loadSnapshot

setData

afterSetData

insertHtml

insertElement

loaded

currentInstance

state

download_M#]</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[JS tech.] CKeditor 專注本業之 Dialog 超棘手 part 4]]></title>
    <link href="http://blog.hinablue.me/entry/JS-tech-CKeditor-part-4/"/>
    <updated>2009-10-04T11:56:00+08:00</updated>
    <id>http://blog.hinablue.me/entry/JS-tech-CKeditor-part-4</id>
    <content type="html"><![CDATA[<p>寫到這裡，我想說一句公道話，那就是，我之前寫的三篇都可以直接扔進垃圾桶，是<span style="font-weight: bold; text-decoration: underline;">一般垃圾</span>不用回收了（翻桌）。編輯器最重要的一個部分，就是自訂的對話框（Dialog），編輯器預設的對話框，跟 FCKeditor 有些許的差異，像是上傳檔案的對話框，在 CKeditor 裡面就沒有在預設工具列內（主要是要提倡跟自家的 CKFinder 合併使用）。</p>

<p>首先呢，在 CKeditor 裡面，所有的對話框都是使用 JavaScript 來產生，所以在設定上並不像以前 FCKeditor 那樣改改他的原始的 html 檔案就能更動對話框，所以關於這一點，對於 JavaScript 不是很熟悉的人恐怕會遇到很多地雷。但是，我看了看還是覺得，這次在 CKeditor 裡面，還是必須要稍微看過原始碼，才能真的有效控制整個 Dialog 的狀況啊（攤手）。</p>

<p>我們繼續來看 Dialog 與 UI，這兩個部分其實是互相綁定的，所以如果把 UI 的部分拿掉，Dialog 可能會半殘。從原始碼看來，UI 有絕大部分是給 Dialog 使用的（CKEDITOR.ui.dialog），所以如果把 UI 的 Core 拿掉的話，那可想而知會發生什麼事情，而 CKEDITOR.dialog 系列的類別，其實是用來做設定（dialogDefinition）的，跟產生對話框並沒有直接的關係。</p>

<p>接著，我們先來看看設定的部分在做些甚麼事情。</p>

<ol><li>CKEDITOR.dialog
用來產生與修改對話框，前提是必須要有已經設定（註冊）好的對話框按鈕元件。</li><li>CKEDITOR.dialog.add
加入（註冊）一個對話框，對話框的對象必須是已定義好的元件（Object）。</li><li>CKEDITOR.dialog.addIframe、CKEDITOR.dialog.addUIElement
歐雷~歐雷~歐雷，目前還無法使用 Iframe，而 UIElement 在 builder 有莫名奇妙的雷。</li><li>CKEDITOR.dialog.exists
檢查對話框是否已存在（已註冊）。
<!-- more -->
</li></ol>


<p>只有一個？那其他的呢？其他的 Class（buttonDefinition、contentDefinition、contentDefinitionObject、dialogDefinition、dialogDefinitionObject、uiElementDefinition、dialogCommand）並不是能夠直接呼叫的 API，而是要在設定中取得元件之後所能夠使用的方法，具體的使用方法依照官方範例如下：</p>

<pre><code>CKEDITOR.on( 'dialogDefinition', function( evt )
{
    var definition = evt.data.definition;
    var content = definition.getContents( 'page1' );
    ...
} );
</code></pre>

<p>至於大家很關心的 Uploader 與 FileBrowser 的部分，官方的<a href="http://docs.cksource.com/CKEditor_3.x/Developers_Guide/File_Browser_%28Uploader%29" target="_blank">簡單說明是這樣的</a>（真的非常簡單）。雖然他也提供了<a href="http://docs.cksource.com/CKEditor_3.x/Developers_Guide/File_Browser_%28Uploader%29/Dialogs_-_Adding_File_Browser" target="_blank">另外一種說明</a>，但是他依舊非常的 CKEDITOR，令人完全看不懂啊！所以說，檔案上傳到底怎麼辦呢？這裡暫時先不提，等到我說完如何加入新的按鈕之後再補上。首先，我們來看看如何在 Toolbar 裡面加入按鈕，底下是一個典型的 CKEDITOR 編輯器的 Toolbar 設定：</p>

<pre><code>var editor = CKEDITOR.replace( 'editor1', {
                toolbar: [
                    ['Source','-','Save','NewPage','Preview','-','Templates'],
                    ['Cut','Copy','Paste','PasteText','PasteFromWord','-','Print', 'SpellChecker', 'Scayt'],
                    ['Undo','Redo','-','Find','Replace','-','SelectAll','RemoveFormat'],
                    ['Form', 'Checkbox', 'Radio', 'TextField', 'Textarea', 'Select', 'Button', 'ImageButton', 'HiddenField'],
                    '/',
                    ['Bold','Italic','Underline','Strike','-','Subscript','Superscript'],
                    ['NumberedList','BulletedList','-','Outdent','Indent','Blockquote'],
                    ['JustifyLeft','JustifyCenter','JustifyRight','JustifyBlock'],
                    ['Link','Unlink','Anchor'],
                    ['Image','Flash','Table','HorizontalRule','Smiley','SpecialChar','PageBreak'],
                    '/',
                    ['Styles','Format','Font','FontSize'],
                    ['TextColor','BGColor'],
                    ['Maximize', 'ShowBlocks','-','About','MyButton']
                ]
            });


// 必須要等待編輯器將 pluginsLoaded 做完才可以繼續做 Dialog 設置與綁定動作。
editor.on( 'pluginsLoaded', function( ev )
{
    // 檢查 Dialog 是否已經存在，不存在才要建立
    if ( !CKEDITOR.dialog.exists( 'myDialog' ) )
    {
        // 註冊一個新的 Dialog，名稱就叫做 'myDialog'
        CKEDITOR.dialog.add( 'myDialog', function( editor )
        {
        // 這裡所返回的，就是 dialogDefinition 的設定。
            return {
                title : 'My Dialog',
                minWidth : 400,
                minHeight : 200,
                contents : [
                    {
                    // 這裡是定義 Dialog 的內容，所使用到的都是那些 UI 與 Dialog 的 Definition。
                    // 裡面的東西有複雜到，待會我會直接寫出檔案上傳的範例。
                    }
                ]
            };
        } );
    }
    // 建立一個新的編輯器命令，並將這個編輯器命令綁定在剛剛建立好的 myDialog 上面。
    editor.addCommand( 'myDialogCmd', new CKEDITOR.dialogCommand( 'myDialog' ) );
    // 綁定剛剛 Toolbar 所設定的 'MyButton' 並且將命令執行綁定在剛剛的編輯器命令上。
    editor.ui.addButton( 'MyButton',
        {
            label : 'My Dialog',
            command : 'myDialogCmd'
        } );
});


id : 'Upload',
hidden : true,
filebrowser : 'uploadButton',
label : editor.lang.image.upload,
// 在 Dialog 中註冊元件
elements :
    [
        {
            type : 'file',
            id : 'upload',
            label : editor.lang.image.btnUpload,
            style: 'height:40px',
            size : 38
        },
        {
            type : 'fileButton',
            id : 'uploadButton',
            filebrowser : 'info:txtUrl',
            label : editor.lang.image.btnUpload,
            'for' : [ 'Upload', 'upload' ]
        }
    ]
</code></pre>

<p><img src="http://static.hinablue.me/blog/7738994095.png" width="561" height="326" /></p>

<p>那檔案會上傳到哪裡呢？好問題！檔案上傳的資料要在 Toolbar 設定完之後另外設定，官方有說明，其實也就是這樣而已：</p>

<pre><code>var editor = CKEDITOR.replace( 'editor1', {
                toolbar: [
                    [...略...],'MyButton']
                ],
                filebrowserUploadUrl : '/uploader/upload.php'
            });
</code></pre>

<p>/uploader/upload.php?CKEditor=editor1&amp;CKEditorFuncNum=1&amp;langCode=en</p>

<p>而這個上傳所要用到的監聽很特殊，需要用 CKEDITOR.tools.callFunction 呼叫並取得返回值，而這個 API 的說明是＂<span style="font-weight: bold; color: rgb(255, 0, 0);">零</span>＂！根據我明查暗訪的結果，這個 callFunction 還必須要先 addFunction，而 addFunction 需要有一個依照 CKEDITOR 所建立的元素（instance），然後這一整串流程在 API 中的說明是＂<span style="font-weight: bold; color: rgb(255, 0, 0);">零</span>＂！</p>

<p>所以，CKEDITOR 的 Dialog 到底是改得更順手，還是更麻煩了呢？各位看倌你覺得呢（茶），其他的 Dialog 跟 UI 我會繼續在找時間補上，畢竟這兩個區塊才是我們真正關心的部分啊！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[JS tech.] Ckeditor GOGOGO~~~ 歐雷~歐雷~歐雷~ part 3]]></title>
    <link href="http://blog.hinablue.me/entry/JS-tech-CKeditor-part-3/"/>
    <updated>2009-09-28T12:14:00+08:00</updated>
    <id>http://blog.hinablue.me/entry/JS-tech-CKeditor-part-3</id>
    <content type="html"><![CDATA[<p>我現在的心情可以這樣表示（<img src="http://static.hinablue.me/emoticons/S4/s4_10.gif" alt="爆炸"  border="0"><img src="http://static.hinablue.me/emoticons/S4/s4_10.gif" alt="爆炸"  border="0"><img src="http://static.hinablue.me/emoticons/S4/s4_10.gif" alt="爆炸"  border="0">）這樣有夠貼切嗎！這個 CKeditor 有些地方實在是超乎我的想像，他做到了一些並不是編輯器迫切需要的功能，舉例來說，他可以控制 DOM 元件。也許你會覺得，我在編輯器裡面可以控制 DOM 元件並不是什麼壞事，偏偏，他控制的是<span style="color: rgb(255, 0, 0); font-weight: bold;">編輯器以外的 DOM 元件</span>。</p>

<p>當我在測試 Event 的時候，發現這個東西並不只有一種，換句話說，他的 Event 控制分成兩組，一組是自訂的監聽與觸發（類似 ActionScript 那樣），另一組是針對 DOM 元件的特定 events 作觸發（諸如 onClick 等）。這兩種 Event 控制分屬不同的類，自定監聽與觸發是單獨屬於 CKEDITOR.event，而針對 DOM 元件的部分則屬於 CKEDITOR.dom.element（等同於 CKEDITOR.document）。</p>

<p>這裡先講自定監聽與觸發的部分，針對 DOM 的因為實在不是屬於編輯器的範圍，所以容後再述。關於自定 Event 的部分其實方法都很簡單，大概有以下幾個項目：</p>

<ol><li>CKEDITOR.event.implementOn
靜態方法，宣告一個 Object 元件，將 Object 元件的資料傳入所呼叫的 Event 中。</li><li>fire
觸發 Event。
</li><li>fireOnce
觸發 Event，但是觸發完成之後會釋放所有的監聽。
</li><li>hasListeners
檢查是否包含監聽函式。
<!-- more -->
</li><li>on
設定監聽函式。
</li><li>removeListeners
移除監聽函式。</li></ol>


<p>另外還有一個類別，叫做 eventInfo，他是用來取得監聽所傳入的一些數值，而且還包含了兩個方法：</p>

<ol><li>data
監聽函式傳入的任何資料。
</li><li>editor
監聽函式傳入的編輯器。</li><li>listenerData
監聽函式傳入的資料（跟 data 不同，容後說明）。
</li><li>name
監聽函式的名稱。
</li><li>sender
監聽自身元件（Object）。
</li></ol>


<p>我們要建立一個自定的監聽，其實方法很簡單：</p>

<pre><code>var myObject = { message : 'Example' };
CKEDITOR.event.implementOn( myObject );
myObject.on( 'someEvent', function(event) {
  alert(event.message);
});
myObject.fire( 'someEvent' );


var myeditor = CKEDITOR.replace( 'editor1' );
var myObject = { message : 'Example' };
CKEDITOR.event.implementOn( myObject );
myObject.on( 'someEvent',
  function(event) {
    alert(event.message);
    alert(event.listenerData.listener);
    alert(event.editor.name);
    alert(event.name);
    alert(event.data.all);
    alert(event.priority);
  },
  { message: 'Example2' },
  { listener: 'Example3' },
  100
);
myObject.fire( 'someEvent', { all: 'Example4' }, myeditor);
</code></pre>

<ol><li>監聽的名稱。</li><li>監聽的函式。</li><li>監聽輸入的值（是個 Scope），會蓋掉 CKEDITOR.event.implementOn 宣告所建立的 Object。</li><li>監聽建立時附帶傳入的資料。</li><li>監聽優先值。</li></ol>


<p>而 fire 則可傳入 data 與 editor 兩項數值，這樣可以分清楚 listenerData 與 data 的不同處嗎（其實我覺得有點畫蛇添足，但是也或許有甚麼地方會需要用到這樣的特性吧）。另外 event 的兩個方法 cancel() 與 stop() 個人是認為跟 fireOnce 有異曲同工之妙。官方的舉例如下：</p>

<pre><code>/* cancel() 範例 */
someObject.on( 'someEvent', function( event )
{
    event.cancel();
});
someObject.on( 'someEvent', function( event )
{
    // This one will not be called.
});
alert( someObject.fire( 'someEvent' ) );  // "true"
/* stop() 範例 */
someObject.on( 'someEvent', function( event )
{
    event.stop();
});
someObject.on( 'someEvent', function( event )
{
    // This one will not be called.
});
alert( someObject.fire( 'someEvent' ) );  // "false"
</code></pre>

<p>最後，CKEDITOR 的 DOM，說穿了根本是一個超級大地雷！他的工作就是用來取代 jQuery 爾等的 DOM 控制器，換句話說，他自己寫了一套像是 jQuery 這樣的 DOM 控制器，來給他的編輯器使用。偏偏，他的 API 並沒有提到如何去控制＂編輯器內部＂的 DOM 元件，所以，個人認為，DOM 那一塊根本是雞肋（或者說，我們都被 jQuery 寵壞了）。</p>

<p>到現在為止，你發現了嗎？
<font style="color: rgb(255, 0, 0);" size="6"><span style="font-weight: bold;">CKEDITOR 到目前為止都只是在作 jQuery 可以做的工作而已啊啊啊啊！</span></font></p>

<p>下一回我們來講地雷等級更高的 UI 跟 Dialog 的部分（這兩項才是編輯器該做的事情）。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[JS tech.] Ckeditor 令人詫異的 basic 模式 part 2]]></title>
    <link href="http://blog.hinablue.me/entry/JS-tech-CKeditor-part-2/"/>
    <updated>2009-09-27T15:19:00+08:00</updated>
    <id>http://blog.hinablue.me/entry/JS-tech-CKeditor-part-2</id>
    <content type="html"><![CDATA[<p>接續<a href="http://blog.hinablue.me/803" target="_blank">上一篇</a>所提到的基本與完整模式，後來我在測試其他的程式碼的時後發現，所謂的基本（basic）模式，的確是很簡單的五個 JavaScript 檔案就可以做到，但是相對的，犧牲掉的部分卻比我想像中的還要多很多。而最令我震驚的部分是，在基本模式中，呼叫編輯器的 CKEDITOR 的其中一支 prototype: instances 會全數失效，所帶來的後果就是，編輯器本身會完全無法控制（所以才叫做 basic 嗎）？</p>

<p>所以，基本上想要客製化這個編輯器，在官方還沒有釋出（或者不打算釋出）各種 plugins 之間的相依性的話，還是得使用完整的版本（就是檔案大小高達 265 KBytes 的版本）。雖然檔案有點過大，但是以現在的網路速度來說，應該還不至於到能感覺到嚴重延遲的地步。</p>

<p>接著，我先來提一下 htmlParser 與 htmlWriter。這兩個函式其實主要是用來產生與寫入標準的 HTML 標記語言，不同的是，htmlParser 的作用其實是用於監聽貼入的內容，而 htmlWriter 則是單純的寫入。我們先來看 htmlParser 的方法有哪些：</p>

<ol><li>onCDATA, function( cdata )
依序取出被貼入的 <sript>...</script> 內的資料。
</li><li>onComment, function( comment )
依序取出被貼入的 <!-- ... --> 內的資料。
</li><li>onTagClose, function( tagName )
依序取出被貼入的 </tag> 的標籤名稱。
</li><li>onTagOpen, function( tagName, attributes, isSelfclosing )
<!-- more -->
依序取出被貼入的 <tag> 的標籤名稱、屬性值與是否為自我結尾標籤（self-closing tag）。
</li><li>onText
依序取出被貼入的 <tag> ... </tag> 內的資料。
</li><li>parse
貼入 HTML 資料。
</li></ol>


<p>扣除第六項之外，其他的方法都是監聽的方法，總共會針對貼入的內容的五種標籤做監聽動作。至於你問我為什麼要監聽這些動作，其實是為了能夠在寫入編輯器的內文或是取出內文時能做一些調整，當然啦，如果你是很單純的使用者打什麼你就存什麼的話，就不需要這麼費功夫了。</p>

<p>接著，htmlParser 還有幾個特別的類別：</p>

<ol><li>CKEDITOR.htmlParser.cdata</li><li>CKEDITOR.htmlParser.comment</li><li>CKEDITOR.htmlParser.element</li><li>CKEDITOR.htmlParser.fragment</li><li>CKEDITOR.htmlParser.text</li></ol>


<p>以上的類別全部都是為了給 htmlWriter 用的，直接呼叫會返回 undefined，至於為什麼他要寫在 API 裡面我也不懂。而且 htmlWriter 幾乎包含了上述所有功能（除了 fragment 之外），這一塊我想官方還要做詳細一點的說明才行，不然無法直接呼叫使用是有點奇怪。</p>

<p>至於 htmlWriter（有雷） 又在做甚麼：</p>

<ol><li>openTag, function( tagName, attribute )
開啟一個 tag，形同 <tag 的意思。但是<span style="color: rgb(255, 0, 0); font-weight: bold;">那個 attribute 是個雷</span>，因為這個函式完全沒有屬性設定的相關動作，所以，我在想這個地方應該是官方有所保留要做甚麼事情用的吧。
</li><li>openTagClose, function( tagName, isSelfclosing )
關閉一個開啟的 tag，形同 <tag.... <span style="color: rgb(255, 0, 0); font-weight: bold;">></span> 的意思。請不要跟 closeTag 搞混，這裡還有是否為自我結尾標籤（self-closing tag）的判定，他是用於關閉一個開啟中的標籤，與成對標籤的關閉不同。</li><li>attribute, function( attName, attValue )
在標籤中設定屬性，這裡的屬性設定才是有效的，而這個設定必須要在 openTagClose 之前完成。
</li><li>closeTag, function( tagName )
關閉成對標籤，形同 <tag.... > ... <span style="color: rgb(255, 0, 0); font-weight: bold;"></tag></span> 的意思。</li><li>text, function( text )
加入內文。
</li><li>comment, function( comment )
加入注釋，形同 <!-- ... --> 的意思。</li><li>lineBreak
在原始碼加入斷行，形同 \n 的意思。</li><li>indentation
在原始碼加入縮排，形同 \t 的意思。
</li><li>setRules, function( tagName, rules )
在標籤中加入標籤規則，這裡的標籤規則總共有五項：
<ul><li>indent，插入縮排（\t）。</li><li>breakBeforeOpen，標籤開啟前斷行（\n）。</li><li>breakAfterOpen，標籤開啟後斷行（\n）。</li><li>breakBeforeClose，標籤關閉前斷行（\n）。</li><li>breakAfterClose，標籤關閉後斷行（\n）。</li></ul>如果需要對某特定標籤設定標籤規則，在標籤開啟（openTag）之前需要先執行標籤規則（setRules）。</li></ol>


<p>截至目前為止，這些都還是屬於 Core 的部分，還有很多可以寫，但是今天看太多 htmlWrite 的 plugin 部份，雷太多被炸得滿頭包（是的，htmlWrite 有分 core 跟 plugin 兩種版本，但是作用相同），所以下次就來講講其他的部分，大概是 editor 與 events 的部分吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[JS tech.] CKeditor 萬事起頭一點都不難 - part 1]]></title>
    <link href="http://blog.hinablue.me/entry/JS-tech-CKeditor-part-1/"/>
    <updated>2009-09-25T10:30:00+08:00</updated>
    <id>http://blog.hinablue.me/entry/JS-tech-CKeditor-part-1</id>
    <content type="html"><![CDATA[<p>如果有聽過 FCKeditor 的人，那我想 <a href="http://ckeditor.com/" target="_blank">CKeditor</a> 就一定要換上來用。雖然是同一家公司出品的編輯器，但是用了這麼久的 FCKeditor，我對於他的 <a href="http://docs.fckeditor.net/FCKeditor_2.x/Developers_Guide/JavaScript_API" target="_blank">API 頁面</a>少成這樣實在有點頭痛，講好聽一點有四頁（驚），講難聽一點只有一頁。自從 CKeditor 推出之後，我一看到他的 <a href="http://docs.fckeditor.net/ckeditor_api/" target="_blank">API 頁面</a>，差點沒痛哭流涕！這才叫做 API 啊（淚）！</p>

<p>CKeditor 是 FCKeditor 的新作品，無論在速度或是 API 上都有很強大的進步。雖然我是在本機測試，但是幾乎瞬間啟動的編輯器畫面還是深得我心啊（大心）。同時官方也提供了完整的 source code 以供參考（<del>做壞事</del>），你可以在<a href="http://svn.fckeditor.net/" target="_blank">官方的 svn</a> 裡面找到 CKeditor 的 nightbuild 版本，如果你心臟夠大顆可以試試看。</p>

<p>同時在 svn 裡面也有提供 <a href="http://svn.fckeditor.net/CKPackager/trunk/" target="_blank">CKPackager</a> 給你下載，你可以用 pack 檔案來打包自己想要的 CKeditor 的功能。但是，因為各種原始檔案並沒有詳細說明個別的相依特性，所以自行打包的話就必須要承擔一點風險，不然編輯器有可能會跛腳。所以，除非必要，不然還是不建議自己打包，你可以使用輕量化的 ckeditor_basic 就好（完整版的 CKeditor 檔案高達 265KBytes）。</p>

<p>首先，我們直接跳過官方那個<a href="http://docs.fckeditor.net/CKEditor_3.x/Developers_Guide" target="_blank">鳥鳥的 Develop's Guide</a> 吧（喂喂）。先從源頭看起，當你下載回來解壓縮之後，你會看到有 _source 這個資料夾，他就是所有的原始檔案，數量龐大，不建議胡亂服用（沒人叫你吃），最重要的地方是 core 資料夾，裡面是整個 CKeditor 的核心，依照 ckeditor_basic 的設定，我們由五個 js 看起。</p>

<ol><li>ckeditor_base.js</li><li>event.js</li><li>editor_basic.js</li><li>env.js</li><li>ckeditor_basic.js</li></ol>


<p>以上就可以架構一個檔案很小五臟俱全（7 KBytes）的編輯器。同時，這五個檔案也建立了 CKeditor 最基本的 Namespace/Classes 所需要的功能。</p>

<ol><li><a href="http://docs.fckeditor.net/ckeditor_api/symbols/CKEDITOR.html" target="_blank">Namespace: CKEDITOR</a></li><li><a href="http://docs.fckeditor.net/ckeditor_api/symbols/CKEDITOR.env.html" target="_blank">Namespace: CKEDITOR.env</a></li><li><a href="http://docs.fckeditor.net/ckeditor_api/symbols/CKEDITOR.editor.html" target="_blank">Classes: CKEDITOR.editor</a></li><li><a href="http://docs.fckeditor.net/ckeditor_api/symbols/CKEDITOR.event.html" target="_blank">Classes: CKEDITOR.event</a></li></ol>


<p>至於這些東西能做些甚麼事情？</p>

<ol><li>event 提供：
<ul><li>觸發（fire, fireOnce）</li><li>監聽（on）</li><li>監聽控制（hasListeners, removeListeners）</li></ul></li><li>editor 提供：
<ul><li>DOM 控制（element, elementMode）</li><li>編輯區方法（暫不詳述，大致上跟 FCK 差不多，但是有一些新的，也有未完成的）
<!-- more -->
</li></ul></li></ol>


<p>對於很基本的編輯器來說，這些控制與方法其實已經能符合八成以上的需求。
<img src="http://static.hinablue.me/blog/8505771796.jpg" width="650" height="292" />
接著我來說幾個很有趣的東西（雖然是屬於 editor_base，但需要額外 plugin 支援）：</p>

<ol><li>虛擬(假)元件（需要 plugin 支援，並未包含在官方發佈的完整 ckeditor.js 中）
</li><li>截取快照</li></ol>


<p>首先，虛擬(假)元件雖然是包含在編輯器的 editor.js 中，但是他是需要你額外把 plugin 給打包進來的功能，個人猜測他還在測試中，所以並沒有真正把他包到完整的版本裡面。他的功能是，利用一張圖片來取代真正要顯示（插入）在編輯器裡的元件。這樣的動作跟 TextCube 的編輯器插入 Flash 的動作很像。他就只是<span style="font-weight: bold; color: rgb(255, 0, 0);">插入一張替代的圖片</span>，然後在<span style="font-weight: bold; color: rgb(255, 0, 0);">儲存的時候</span>再將圖片給<span style="font-weight: bold; color: rgb(255, 0, 0);">換回真正要插入的 code</span>。</p>

<p>其實這個功能我已經在 FCKeditor 實作出來了，所以我很樂見他有內建這樣的功能。但是，稍微深入一點，他這個方法要呼叫還不是那麼容易，首先，你要先準備一組符合 CKEDITOR 標準的元件給他，換句話說，你必須要用 CKEDITOR API 先建立一個元件（就是你要插入的 code），然後再利用這個方法把元件換成假的。至於說，這樣作會不會多此一舉？我個人是覺得見仁見智，你要用正規表示式去洗其實也可以啦。</p>

<p>至於截取快照，他是另一種＂儲存＂的方式，不真的儲存，而是將已經輸入好的內容放到某個變數裡面（就是丟到記憶體裡面啦），然後你可以隨時取出來用。這樣可以解決遠端連線出問題的時候資料的保存，但是缺點是，萬一客戶端這邊當機，也一樣一去不復返啊（茶）。</p>

<p>就暫時先到這，接下來將會介紹 htmlParser/htmlWrite 這個核心命脈 plugin（笑）。</p>
]]></content>
  </entry>
  
</feed>
