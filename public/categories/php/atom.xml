<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: PHP | HINA::工程幼稚園]]></title>
  <link href="http://blog.hinablue.me/categories/php/atom.xml" rel="self"/>
  <link href="http://blog.hinablue.me/"/>
  <updated>2011-11-29T23:02:43+08:00</updated>
  <id>http://blog.hinablue.me/</id>
  <author>
    <name><![CDATA[hinablue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[PHP note.] 微型專案 Part 1]]></title>
    <link href="http://blog.hinablue.me/entry/php-note-micro-project-note-part-1/"/>
    <updated>2011-11-20T23:38:00+08:00</updated>
    <id>http://blog.hinablue.me/entry/php-note-micro-project-note-part-1</id>
    <content type="html"><![CDATA[<p>這是技術外加嘴砲文。</p>

<p>專案就是這樣，從許多大中小型的 Framework 挑一個適合的來用，萬一沒有中意的，那只好-複製貼上-自己刻一個比較快。當然，不是什麼時候都可以重造輪子的，案子很急很趕-屎都在門邊-的時候，挑幾個小型的 Framework 快速上手應該是比較好的解法。</p>

<p>那我寫這個幹麼（被揍飛！</p>

<h3>需求認知</h3>

<p>快速開發，又得要考慮多人同時進行，版本控制就很重要，git 當然是不二選擇。除了 git 我想不到其他的辦法，沒辦法，誰叫 git 這麼好用呢。版本控制確定了，那麼就得決定專案需求的方向。各大類型的 Framework 總是免不了一大堆的設定、Controllers、Modules、Views、Plugins 等等，當我不需要得時候，是不是能有一個檔案搞定的解法呢？</p>

<p>又，資料庫怎麼辦？在 gitHub 上面不乏有許多小型的資料庫工具可用，像是以 <a href="http://deep.tw/" target="_blank">@pct</a> 的 <a href="https://github.com/pct/4money" target="_blank">4money</a> 專案所使用的 <a href="https://github.com/j4mie/idiorm" target="_blank">idiorm</a> 就是一個不錯的工具。-當然，如果你想自己用 PDO 來刻也是可以的-。</p>

<!-- more -->


<p>那，Views 怎麼辦呢？用 Smarty 嗎？還是？</p>

<h3>確認需求</h3>

<p>所以，我決定這麼做：<ul><li>自己刻一個簡易的 Bootstrap，然後可以使用 Controllers, Plugins, Modules 等等。</li><li>資料庫使用 idiorm。
</li><li>Views 直接使用 PHP（其實 PHP 本身就是樣板引擎）。</li></ul>我要做一個 RESTful 的 API 介面，其實用不太到 Views 的功能，所以才會選擇用 PHP 自己刻。那麼，Bootstrap 該怎麼開始比較好？</p>

<h3>自己刻，比較快？</h3>

<p>真的嗎？</p>

<p>首先，我知道 RESTful 的 API 需要回傳 HTTP 狀態碼，然後要將 body 填入回傳的資訊。我們有兩種方法，一種是 JSON，另一種是 XML，所以我們就會有兩種回傳資訊的功能。</p>

<p>HTTP 狀態碼則可以用 header() 來送，簡單明瞭（喂
``` php A simple header()
&lt;?php</p>

<pre><code>header('HTTP/1.0 400 BAD REQUEST');
</code></pre>

<p>?>
```</p>

<p>那麼，Bootstrap 還是沒有解決啊？
``` php bootstrap.php
&lt;?php</p>

<pre><code>class Controller {
    public function __construct() {
    }
}
class Container extends Controller {
    public function __construct() {
    }
    public function startup() {
        // 開始跑
    }
}
$container = new Container();
$container-&gt;startup();
</code></pre>

<p>?>
```</p>

<p>那我們的 Controllers 呢？舉一個簡單的例子，我們開一個目錄叫做 controllers，然後裡面放了個 Api.php 這樣。
``` php controllers/Api.php
&lt;?php</p>

<pre><code>class Api extends Controller {
    public function __construct() {
    }
    public function startup() {
        // 開始跑
    }
}
</code></pre>

<p>?>
```</p>

<p>然後訪問 index.php 的時候，發現 Api.php 並不會動，那一定是有什麼-奇怪的東西混進來了-寫錯了。所以我們再來看一下 index.php 是不是有漏掉的地方。
``` php bootstrap.php
&lt;?php</p>

<pre><code>class Controller {
    public function __construct() {
    }
}
class Container extends Controller {
    private $controller;
    public function __construct() {
    }
    public function startup() {
        // 開始跑
        require_once 'controllers/Api.php';
        $this-&gt;controller = new Api;
        $this-&gt;controller-&gt;startup();
    }
}
$container = new Container();
$container-&gt;startup();
</code></pre>

<p>?>
```</p>

<p>疑？那最近每一套 Framework 都很夯的 Routing 功能，或是去除掉 index.php 的動作要怎麼做呢？當然，如果你有用過 Rewrite Engine 的話，這個問題應該很快就能夠解決。要怎麼把網址拆開來，依照 Controller/Method/Value1/Value2 來傳遞到你的 Controller 裡面，這就是請自己努力的地方了。而其實，你也可以參考各大 Framework 的作法，也是可以學到一點東西的。</p>

<p>所以，我把網址所傳入的東西依照 Controller/Method/Value1/Value2 拆開來了，那麼，我們的 Container 就可以這樣改寫：
``` php bootstrap.php
&lt;?php</p>

<pre><code>class Container extends Controller {
    private $controller;
    private $segments;
    public function __construct() {
    }
    public function startup() {
        // 開始跑
        // 做了一狗票的事情，把網址轉成下列格式，存入 segments 中。
        // Controller/Method/Value1/Value2
        // 所以我們就把 Controller 提出來
        $controllerName = ucfirst(strtolower(array_shift($this-&gt;segments)));
        $controllerPath = dirname(__FILE__) . DIRECTORY_SEPArATOR . 'controllers'. DIRECTORY_SEPARATOR . $controllerName . '.php';
        if (file_exists($controllerPath)) {
            require_once $controllerPath;
            $this-&gt;controller = new $controllerName;
            $this-&gt;controller-&gt;startup();
        } else {
            die('Controller does not exists.');
        }
    }
}
</code></pre>

<p>?>
```</p>

<p>方法呼叫也是一樣，繼續改寫 Container 的部份：
``` php bootstrap.php
&lt;?php</p>

<pre><code>        if (file_exists($controllerPath)) {
            require_once $controllerPath;
            $this-&gt;controller = new $controllerName;
            $this-&gt;controller-&gt;startup();
            $methodName = ucfirst(strtolower(array_shift($this-&gt;segments)));
            if (method_exists($this-&gt;controller, $methodName)) {
                $this-&gt;controller-&gt;$methodName();
            } else {
                die('Controller's method does not exists.');
            }
        } else {
            die('Controller does not exists.');
        }
</code></pre>

<p>?>
```</p>

<p>傳值呢？我們有好多好多的值要傳，怎麼傳？在 PHP 中有一個方法，叫做 <a href="http://php.net/manual/en/function.call-user-func-array.php" target="_blank"><code>call_user_func_array</code></a>，使用的方式也很簡單，我們看 code 比較快：
``` php bootstrap.php
&lt;?php</p>

<pre><code>            if (method_exists($this-&gt;controller, $methodName)) {
                // 原本的呼叫方式我們不要用了
                // $this-&gt;controller-&gt;$methodName();
                call_user_func_array( array(&amp;$this-&gt;controller, $methodName), $this-&gt;segments );
            } else {
                die('Controller's method does not exists.');
            }
</code></pre>

<p>?>
```</p>

<p>那，如果我要回傳呢？我們在這裡用 JSON 回傳的方式來舉例說明。我們寫一個靜態方法在 Controller 裡面，用靜態的方式來呼叫就好了。
``` php bootstrap.php</p>

<pre><code>&lt;?php 
class Controller {
    public function __construct() {
    }
    public static function responseJSON($data = null) {
        if ($data !== null) {
            if (!is_array($data)) {
                $data = array((string) $data);
            }
            if ($data = json_encode($data)) {
                header("pragma: no-cache");
                header("cache-control: no-store, no-cache, max-age=0, must-revalidate");
                header("content-type: text/x-json; charset=utf-8");
                header("X-JSON: ". $data);
                echo $data;
                exit;
            } else {
                die('JSON object invalid.');
            }
        } else {
            die('JSON object invalid.');
        }
    }
}
// ... 後面省略一萬行
?&gt;
</code></pre>

<p>```</p>

<p>你可以這麼做：
``` php controllers/Api.php</p>

<pre><code>&lt;?php 
class Api extends Controller {
    public function __construct() {
    }
    public function startup() {
        // 開始跑
    }
    public function ThereIsTheTest() {
        // 這裡省略一萬行
        $data = array('value' =&gt; 'There is the test');
        Controller::responseJSON($data);
    }
}
?&gt;
</code></pre>

<p>```</p>

<p>是的，這樣一個簡易的 Bootstrap 就完成了。</p>

<h3>錯誤控制</h3>

<p>上面看到不少 die()，寫太多的話你以後要除錯真的會 DIE！不過這個下次再談（疑）。</p>

<h3>資料控制</h3>

<p>idiorm 我們下次見（喂喂）。</p>

<h3>小結</h3>

<p>以入門者來說，要寫一個簡易的控制器並不是難事，你看<strong>像我這種弱雞</strong>都寫得出類似 RESTful API 的東西了，可見這並非太過於困難。-只要有心，人人都可以自己刻-。程式碼的部份無法交代太多，不過，已經有一個專案是以這種類似模式在開發，然後最近要正式上線測試了。</p>

<p>所以說，在程式上還是有很多眉眉角角是必須要去注意的。就像是你永遠沒辦法預防使用者在 ajax 的時候，按下 ESC 或是 F5 鍵一樣（這在瀏覽器動作上，是有可能中斷 ajax 傳輸的操作）。</p>

<p>這是一個很入門的輪子，就像是 @pct 說得，<strong>如果沒有辦法改變世界，那最起碼改變自己的人生</strong>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[mongoDB note.] Ubuntu + MongoDB + CakePHP = 芒果蛋糕]]></title>
    <link href="http://blog.hinablue.me/entry/mongodb-note-ubuntu-apache-php-mongodb-quick-start/"/>
    <updated>2011-07-13T18:07:00+08:00</updated>
    <id>http://blog.hinablue.me/entry/mongodb-note-ubuntu-apache-php-mongodb-quick-start</id>
    <content type="html"><![CDATA[<p>這邊有一篇文章：
<a href="http://mark-story.com/posts/view/using-mongodb-with-cakephp">http://mark-story.com/posts/view/using-mongodb-with-cakephp</a></p>

<p>這裡有一篇不錯的影片：
<a href="http://www.vimeo.com/8005503">http://www.vimeo.com/8005503</a></p>

<p>mongoDB 在 PHP 官方安裝教學：
<a href="http://www.mongodb.org/display/DOCS/PHP+Language+Center">http://www.mongodb.org/display/DOCS/PHP+Language+Center</a></p>

<p>10gen 的影片：
<a href="http://www.10gen.com/presentation/mongosf-2011/php-development-with-mongodb">http://www.10gen.com/presentation/mongosf-2011/php-development-with-mongodb</a></p>

<!-- more -->


<p>PHP 要支援 mongo 可以用 pecl 安裝：</p>

<blockquote><p>sudo pecl install mongo</p></blockquote>

<p>然後在 /etc/php5/conf.d 加入一個 mongodb.ini 檔案，寫入這個：</p>

<blockquote><p>extension=mongo.so</p></blockquote>

<p>重新啟動 Apache 跟 php5-fpm（如果你有用的話），查看 phpinfo() 應該就會看到 mongo 了。</p>

<p>mongoDB 在 Ubuntu/Debian 上面的安裝過程：
<a href="http://www.mongodb.org/display/DOCS/Ubuntu+and+Debian+packages">http://www.mongodb.org/display/DOCS/Ubuntu+and+Debian+packages</a></p>

<p>在 Ubuntu 上面，安裝 10gen 版本支援的 mongoDB 大抵上是這樣：</p>

<blockquote><p>sudo apt-key adv --keyserver keyserver.ubuntu.com --recv 7F0CEB10</p></blockquote>

<p>打開 /etc/apt/source.list 在最後面加入這一行：
deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen</p>

<p>sudo apt-get update
sudo apt-get install <strong>mongodb</strong>-10gen</p>

<p>然後可以跑一下 mongo --version 看看有沒有成功。</p>

<p>最後是跟 CakePHP 結合，這已經有神人寫好了（這是給 CakePHP 1.3 用的）！</p>

<p><a href="https://github.com/ichikaway/mongoDB-Datasource">####https://github.com/ichikaway/mongoDB-Datasource####</a></p>

<p><img src="http://static.hinablue.me/emoticons/S4/s4_08.gif" border="0" alt="幹得好" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[ImageMagick note.] Lomography style]]></title>
    <link href="http://blog.hinablue.me/entry/imagemagick-note-lomography-style/"/>
    <updated>2011-06-14T23:46:00+08:00</updated>
    <id>http://blog.hinablue.me/entry/imagemagick-note-lomography-style</id>
    <content type="html"><![CDATA[<p>原文：
<a href="http://the.taoofmac.com.nyud.net:8090/space/blog/2005/08/23/2359">http://the.taoofmac.com.nyud.net:8090/space/blog/2005/08/23/2359</a></p>

<p>我把他作成 bash 來跑，效果不錯，放張比較圖片給大家看看。</p>

<p>轉換前：
<img src="http://static.hinablue.me/blog/3226565254.jpg" width="467" height="700" /></p>

<p>轉換後：
<img src="http://static.hinablue.me/blog/9440785165.jpg" width="467" height="700" /></p>

<p>係數的部份，可以自行參考 ImageMagick 官方說明。底下附上 shell-script 給大家參考。基本上就是，你丟到圖片資料夾中執行，他只會掃描第一層的所有 JPG，然後全部套上 Lomography 風格後，儲存在 lomo 子目錄底下。</p>

<!-- more -->


<p>切記，檔案不要太大，不然 CPU 應該會燒起來（喂）。
``` bash convert.sh</p>

<pre><code>#!/bin/bash
if [ ! -d "./lomo" ]; then
    `mkdir lomo`
fi
`/usr/bin/convert -size 100x100 xc: -fx '(1-(2*i/w-1)^4)*(1-(2*j/h-1)^4)' ./lomo/lomo_mask.png`
for file in `find ./ -maxdepth 1 -type f -iregex ".*\(jpg\|jpeg\)"`
do
    identify=`/usr/bin/identify -format '%wx%h' "$file"`
    if [ ! -f "./lomo/"$identify"_mask.png" ]; then
        `cp ./lomo/lomo_mask.png ./lomo/"$identify"_mask.png`
        `/usr/bin/mogrify -resize "$identify"! -gaussian 0x5 ./lomo/"$identify"_mask.png`
    fi
    `/usr/bin/convert "$file" -contrast -level 120 -modulate '100,120' ./lomo/"$file".png`
    `/usr/bin/composite -compose Multiply ./lomo/"$identify"_mask.png ./lomo/"$file".png ./lomo/"$file"`
done
`rm ./lomo/*.png`
</code></pre>

<p>```</p>

<p>大概就是這樣（笑）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Plupload note.] 重新命名的錯誤]]></title>
    <link href="http://blog.hinablue.me/entry/plupload-note-upload-example-filename-issue/"/>
    <updated>2011-06-02T00:43:00+08:00</updated>
    <id>http://blog.hinablue.me/entry/plupload-note-upload-example-filename-issue</id>
    <content type="html"><![CDATA[<p>``` php upload.php</p>

<pre><code>// Make sure the fileName is unique but only if chunking is disabled
if ($chunks &lt; 2 &amp;&amp; file_exists($targetDir . DIRECTORY_SEPARATOR . $fileName)) {
    $ext = strrpos($fileName, '.');
    $fileName_a = substr($fileName, 0, $ext);
    $fileName_b = substr($fileName, $ext);
    $count = 1;
    while (file_exists($targetDir . DIRECTORY_SEPARATOR . $fileName_a . '_' . $count . $fileName_b))
    $count++;
    $fileName = $fileName_a . '_' . $count . $fileName_b;
</code></pre>

<!-- more -->


<pre><code>}
</code></pre>

<p>```</p>

<p>我們藉由紀錄 chunk 與 chunks 大概會是這個樣子：</p>

<p><code>javascript console.log
chunk: 0, chunks: 1
chunk: 1, chunks: 2
chunk: 2, chunks: 3
chunk: 3, chunks: 4
chunk: 4, chunks: 5
</code></p>

<p>應該是第一次上傳檔案就必須檢查是否有重複檔名，然後將之避開。
``` php upload.php</p>

<pre><code>// Make sure the fileName is unique but only if chunking is disabled
if ($chunk == 0 &amp;&amp; file_exists($targetDir . DIRECTORY_SEPARATOR . $fileName)) {
    $ext = strrpos($fileName, '.');
    $fileName_a = substr($fileName, 0, $ext);
    $fileName_b = substr($fileName, $ext);
    $count = 1;
    while (file_exists($targetDir . DIRECTORY_SEPARATOR . $fileName_a . '_' . $count . $fileName_b))
    $count++;
    $fileName = $fileName_a . '_' . $count . $fileName_b;
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Plupload note.] 微妙的錯誤]]></title>
    <link href="http://blog.hinablue.me/entry/plupload-note-something-about-upload-filename-issue/"/>
    <updated>2011-05-20T17:54:00+08:00</updated>
    <id>http://blog.hinablue.me/entry/plupload-note-something-about-upload-filename-issue</id>
    <content type="html"><![CDATA[<p>Plupload 這個上傳器，我想應該不會很陌生吧（應該）。他有一個很微妙的錯誤。請看上傳端 PHP 處理的這個部份：
``` php upload.php</p>

<pre><code>// Make sure the fileName is unique but only if chunking is disabled
if ($chunks &lt; 2 &amp;&amp; file_exists($targetDir . DIRECTORY_SEPARATOR . $fileName)) {
        $ext = strrpos($fileName, '.');
        $fileName_a = substr($fileName, 0, $ext);
        $fileName_b = substr($fileName, $ext);
        $count = 1;
        while (file_exists($targetDir . DIRECTORY_SEPARATOR . $fileName_a . '_' . $count . $fileName_b))
                $count++;
</code></pre>

<!-- more -->


<pre><code>        $fileName = $fileName_a . '_' . $count . $fileName_b;
}
</code></pre>

<p>```</p>

<p>這次會遇到這個東西，是因為在大量且多人環境下，使用 plupload 上傳時，會發現檔案被莫名覆蓋，而導致使用者端出現異常。雖然這種命名重複的老梗瞬間就解決了，不過還是紀錄一下。</p>

<p>前端可以這樣做：
``` javascript custom-plupload.js</p>

<pre><code>var uploader = new plupload.Uploader({
    // 設定就略過囉
});
/**
 * 在檔案加入後，開始上傳之前，我們將檔名動點手腳。
 */
uploader.bind('BeforeUpload', function(up, files) {
    files.name = files.id + '-' + files.name;
});
/**
 * 在檔案上傳結束後，由於前端會顯示檔案名稱，所以必須把動手腳的檔名換回來。
 */
uploader.bind('BeforeUpload', function(up, files, response) {
    files.name = files.name.replace(files.id + '-', '');
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
